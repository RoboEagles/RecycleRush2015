// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.RecycleRush;
    

import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Gyro;
import edu.wpi.first.wpilibj.PIDSource.PIDSourceParameter;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

import java.util.Vector;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static SpeedController driveTraindriveLeft;
    public static SpeedController driveTraindriveRight;
    public static RobotDrive driveTrainrobotMainDrive;
    public static Gyro driveTraindirectionalGyro;
    public static SpeedController centeringMechanismcenteringLeft;
    public static SpeedController centeringMechanismcenteringRight;
    public static SpeedController liftingMechanismliftMotor;
    public static Encoder liftingMechanismliftMechanismInput;
    public static DigitalInput liftingMechanismswitchHigh;
    public static DigitalInput liftingMechanismswitchLow;
    public static DigitalInput liftingMechanismtoteBool;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public static Accelerometer robotAccelerometer = new BuiltInAccelerometer(Accelerometer.Range.k4G); 
    	// FOR ACCELEROMETER, Y AXIS = X AXIS BECAUSE IT IS PERPENDICULAR TO GROUND
    
    public static double drift,
    					timerDelay = 1,
    					timerA,
    					driftRate,
    					accelDriftY,
    					accelDriftZ;

    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTraindriveLeft = new Talon(0);
        LiveWindow.addActuator("DriveTrain", "driveLeft", (Talon) driveTraindriveLeft);
        
        driveTraindriveRight = new Talon(1);
        LiveWindow.addActuator("DriveTrain", "driveRight", (Talon) driveTraindriveRight);
        
        driveTrainrobotMainDrive = new RobotDrive(driveTraindriveLeft, driveTraindriveRight);
        
        driveTrainrobotMainDrive.setSafetyEnabled(true);
        driveTrainrobotMainDrive.setExpiration(0.1);
        driveTrainrobotMainDrive.setSensitivity(0.5);
        driveTrainrobotMainDrive.setMaxOutput(1.0);
        driveTrainrobotMainDrive.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);
        driveTrainrobotMainDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);        

        driveTraindirectionalGyro = new Gyro(0);
        LiveWindow.addSensor("DriveTrain", "directionalGyro", driveTraindirectionalGyro);
        driveTraindirectionalGyro.setSensitivity(0.001);
        centeringMechanismcenteringLeft = new Talon(3);
        LiveWindow.addActuator("centeringMechanism", "centeringLeft", (Talon) centeringMechanismcenteringLeft);
        
        centeringMechanismcenteringRight = new Talon(4);
        LiveWindow.addActuator("centeringMechanism", "centeringRight", (Talon) centeringMechanismcenteringRight);
        
        liftingMechanismliftMotor = new Victor(2);
        LiveWindow.addActuator("liftingMechanism", "liftMotor", (Victor) liftingMechanismliftMotor);
        
        liftingMechanismliftMechanismInput = new Encoder(0, 1, false, EncodingType.k4X);
        LiveWindow.addSensor("liftingMechanism", "liftMechanismInput", liftingMechanismliftMechanismInput);
        liftingMechanismliftMechanismInput.setDistancePerPulse(0.043984);
        liftingMechanismliftMechanismInput.setPIDSourceParameter(PIDSourceParameter.kDistance);
        liftingMechanismswitchHigh = new DigitalInput(2);
        LiveWindow.addSensor("liftingMechanism", "switchHigh", liftingMechanismswitchHigh);
        
        liftingMechanismswitchLow = new DigitalInput(3);
        LiveWindow.addSensor("liftingMechanism", "switchLow", liftingMechanismswitchLow);
        
        liftingMechanismtoteBool = new DigitalInput(4);
        LiveWindow.addSensor("liftingMechanism", "toteBool", liftingMechanismtoteBool);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        driveTraindirectionalGyro.initGyro();
        driveTraindirectionalGyro.reset();
        timerA = Timer.getMatchTime();
        Timer.delay(timerDelay);
        drift = driveTraindirectionalGyro.getAngle();
        driftRate = drift / timerDelay;
        accelDriftY = robotAccelerometer.getY() / timerDelay;
        accelDriftZ = robotAccelerometer.getZ() / timerDelay;
        
    }
}
