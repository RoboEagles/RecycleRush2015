// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.RecycleRush.subsystems;

import org.usfirst.frc4579.RecycleRush.OI;
import org.usfirst.frc4579.RecycleRush.Robot;
import org.usfirst.frc4579.RecycleRush.RobotMap;
import org.usfirst.frc4579.RecycleRush.commands.*;

import edu.wpi.first.wpilibj.Gyro;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;


public class DriveTrain extends Subsystem {
	
	private OI oi = new OI();
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController driveLeft = RobotMap.driveTraindriveLeft;
    SpeedController driveRight = RobotMap.driveTraindriveRight;
    RobotDrive robotMainDrive = RobotMap.driveTrainrobotMainDrive;
    Gyro directionalGyro = RobotMap.driveTraindirectionalGyro;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public static double currentDistance = 0.;
    public double acceleration = 0.,
    				velocity = 0.,
    				time = 0.;
    
    
    private double	lpfK = 0.2,
    				xOut = 0.0,
    				xOutOld = 0.0,
    				yOut = 0.0,
    				yOutOld = 0.0;
    						
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public static void resetDistance() {
    	currentDistance = 0.;
    }
    
    public double deltaT() {
    	double matchTime = Timer.getFPGATimestamp();
    	double deltaT = matchTime - time;
    	time = matchTime;
    	return deltaT;
    }
    public double gyroDrift() {
    	return RobotMap.driftRate * (Timer.getMatchTime() - RobotMap.timerA);
    }
    
    public double getYAcceleration() {
    	double drift = RobotMap.accelDriftY * (Timer.getMatchTime() - RobotMap.timerA);
    	return RobotMap.robotAccelerometer.getY() - drift;
    }
    
    public double getZAcceleration() {
    	double drift = RobotMap.accelDriftZ * (Timer.getMatchTime() - RobotMap.timerA);
    	return RobotMap.robotAccelerometer.getZ() - drift;
    }
    
    public double getVectorAcceleration() { // Returns net vector magnitude of acceleration    	
    	return Math.sqrt(
    			Math.pow(RobotMap.robotAccelerometer.getZ(), 2) +
    			Math.pow(getYAcceleration(),  2));
    }
    
    public double getVelocity() {
    	double deltaT = deltaT();
    	velocity = ((velocity + (getVectorAcceleration()*deltaT))/2); //Average of velocities.
    	return velocity;
    }
    
    public double getDistance() {
    	return getVelocity()*deltaT();
    }
    
    public boolean moveBy(double distance) {
    	if(getDistance() < distance) {
    		return false;
    	} else {
    		resetDistance();
    	}
    	return true;
    }
    
    public double getAngle() { // Gets angle that is adjusted for drift
    	double temp = directionalGyro.getAngle(),
    		actualAngle = temp - gyroDrift();
    	return actualAngle;
    }
   
    
    public void drive(double turnAngle, double speed) { // Takes your turn angle. Not bearing
    	
    	double currentAngle = getAngle(),
    			dynamicError = turnAngle - currentAngle,
    			kError = (1.0/180.0),
    			multiplier = dynamicError > 0 ? 1. : -1.,
    			turnError = dynamicError * kError,
    			rightTurnError = turnError,
    			leftTurnError = turnError;
    			
    			if (turnError > 0) {
    				rightTurnError = -turnError;
    			} else {
    				leftTurnError = -turnError;
    			}
    			
    			driveLeft.set(speed + (leftTurnError*multiplier));
    			driveRight.set(-1*(speed + (rightTurnError*multiplier)));
    	
    }
    
	public void setDrive() {
		double x = 2*(oi.getdriveStick().getZ())/3, //getZ() for yaw, getX() for standard
				y = oi.getdriveStick().getY(); 
/*		
		RobotMap.driveTrainrobotMainDrive.arcadeDrive(
				-(y/Math.abs(y))*Math.pow(y,(2)), -(x/Math.abs(x))*Math.pow(x, (2))
		);
*/
/*		Alternate low pass filter for drive speed commands.  NOT FOR AUTONOMOUS!
 *      Adjust the value of lpfK, above, to adjust how fast you get to full speed, or stop from full speed.
 */
		xOut = xOutOld + lpfK*(x - xOutOld);
		yOut = yOutOld + lpfK*(y - yOutOld);
		RobotMap.driveTrainrobotMainDrive.arcadeDrive(yOut, xOut);
		xOutOld = xOut;
		yOutOld = yOut;
	}
	
	public void stop() {
		robotMainDrive.drive(0.0,0.0);
	}
	
	
}

