// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.RecycleRush3.subsystems;

import org.usfirst.frc4579.RecycleRush3.Robot;
import org.usfirst.frc4579.RecycleRush3.RobotMap;
import org.usfirst.frc4579.RecycleRush3.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;
import edu.wpi.first.wpilibj.Gyro;


/**
 *
 */
public class Drivetrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController leftMotor = RobotMap.drivetrainLeftMotor;
    SpeedController rightMotor = RobotMap.drivetrainRightMotor;
    RobotDrive drivebase = RobotMap.drivetrainDrivebase;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    private double xLast, yLast, zLast = 0.;  //for low pass filter.
    private double lpfK = 0.2;                //low pass filter time constant.
	private final double width = 20.;         //width between drive wheels, inches.    
	private final double w = width / 2.0;     //to compute wheel speeds in a turn.
	private final double epsilon = 0.001;     //keeps demoninator from going to zero.
	private final double spinPoint = 0.8;     //Joystick value, 0 -> 1, defines input 
											  //where robot pivots on inside wheel.
	private final double k = (width/2.0 * spinPoint) / (Math.E * (1.0-spinPoint));
										      //joystick input scale factor for turns.

    public void drive(double turnError, double speed) { // SHOULD BE CALLED IN ITERATIONS AS TO ADJUST FOR TURNING
    	double k = 1.0/180.0,
    		speedAdjust = turnError * k;   	
    	leftMotor.set(speed - speedAdjust);
    	rightMotor.set(-speed - speedAdjust);
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public void driveManual(Joystick stick)  {
    	//square the inputs.
    	double x = Math.pow(stick.getX(), 2);
    	double y = Math.pow(stick.getY(), 2);
    	double z = Math.pow(stick.getZ(), 2);
    	//low pass filter the inputs.
    	x = xLast + lpfK * (x - xLast);
    	y = yLast + lpfK * (y - yLast);
    	z = zLast + lpfK * (z - zLast);
    	//Save these values for next iteration.
    	xLast = x;
    	yLast = y;
    	zLast = z;
    	//This should improve driving by eliminating loss of power in y direction.
    	y = Math.sqrt(x * x + y * y) * (y / Math.abs(y));  
    	//drive the robot.
    	drivebase.arcadeDrive(y, z);    	
    }
    
    public void driveAuto(double speed, double rotation)  {
    	//in the library, the rotation value is used to create a delta speed to each wheel.
    	drivebase.arcadeDrive(speed, rotation);
    }
    
    public void driveTurn(double speed, double turnRadius)  {
    	//This method should give a more predictable turn control.
    	//The basic equation is delta = (speed / radius) * (width / 2).
    	//speed is the expected speed of center point of wheel axis (-1 to +1).
    	//turnRadius (inches) is positive to the right, 
    	//and negative to the left of center point (-1E6 to +1E6 inches).
    	//A turnRadius of +/-width/2 should pivot on a wheel.
    	//delta is half the speed differential between the wheels.
    	double speedLeft, speedRight, delta, overspeed;
    	double radius = Math.abs(turnRadius);
    	double sign = turnRadius / radius;
    	//Handle a zero turn radius to avoid divide by zero.
    	if (radius < 0.1)  {
    		radius = 0.1;
    		turnRadius = 0.1 * sign;
    	}
    	//Calculate the differential speed required.
        delta = width * 0.5 * speed / radius;
        overspeed = speed + delta;  //Note: does not account for negative speed input.
        //Adjust speed and delta to limit outer wheel drive speed.
        //This calculation maintains the turnRadius, not the speed.
        if (overspeed > 1.0)  {
        	speed /= overspeed;
        	delta /= overspeed;
        }
        //Calculate the left and right motor speeds, and set motors.
        speedLeft = speed + (delta * sign);
        speedRight = speed - (delta * sign);
        leftMotor.set(speedLeft);
        rightMotor.set(speedRight);
        //System.out.println("Left=" + speedLeft + "  Right=" + speedRight);
    }
    
    public void stop()  {
    	leftMotor.set(0);
    	rightMotor.set(0);
    }
    
    public double getWidth()  {
    	return width;
    }
    
    /* This drive method is designed to maintain controlled robot motion, either straight
     * forward or backwards, or right or left turns, and tries to compensate for movement
     * errors using the gyro rate value.   This method is expected to be used with 
     * manual joystick inputs.
     * 
     * @param double speed - The speed of the outside wheel of the turning robot, [-1 to +1].
     * @param double turn - The turn input from the joystick, [-1 to 0 to +1].  A turn 
     *                      input of spinPoint is set to rotate the robot about the inside
     *                      wheel.  spinPoint is an adjustable constant for the class.
     *                      Larger values of turn will pivot inside the wheel base, causing
     *                      the inside wheel to rotate opposite the ouside wheel.
     * @param boolean squareSpeed - Allows for squaring the speed input to reduce sensitivity.                     
     */
    public void driveControlled(double speed, double turn, boolean squareSpeed)  {
    	if (squareSpeed) speed = (speed/Math.abs(speed)) * (speed * speed);
    	//Do all calculations with a positive turn setting.
    	double t = Math.abs(turn);
    	//Map the turn input to a radius value.
    	if (t < epsilon) t = epsilon;
    	double radius = k * ((Math.E / t) - Math.E);
    	//Calculate the fast and slow wheel speeds.
    	double slow = speed * (radius - w) / (radius + w);
    	//Calculate the expected rate of turn based on wheel speed ratio.
    	double omega = speed / slow * (turn/Math.abs(turn)) * 2.0 * Math.PI;
    	//Adjust the slow wheel to compensate.
    	double g = Robot.measurement.getGyroRate();
    	slow = slow * omega / g;
    	//Set motor speeds.
    	//Case for straight ahead.
    	if (t < epsilon)  {
    		leftMotor.set(speed);
    		rightMotor.set(speed);
    	}
    	//Case for right turn.
    	else if (turn > 0.0)  {
    		leftMotor.set(speed);
    		rightMotor.set(slow);
    	}
    	//Case for left turn.
    	else if (turn < 0.0)  {
    		leftMotor.set(slow);
    		rightMotor.set(speed);
    	}
    	System.out.println("speed="+speed+" turn="+turn+  " radius="+radius);
    	System.out.println(" slow="+slow+ " omega="+omega+" gyro="+g);
    }
    
    /* This drive method allows for setting the turn radius directly, and the turn
     * is controlled by using the gyro rate value.  To go straight, use a very
     * large radius value, like 10,000.  Since this method is expected to be used
     * in Autonomous only, there is no need to square the speed input.
     * 
     * @param double speed - speed value from [-1 to 0 to +1].  Negative values move backwards.
     * @param double radius - the expected turn radius in inches measured from the center
     *                        of the robot wheel base.
     */
    public void driveRadius(double speed, double radius)  {
    	//Use positive radius value for computation.
    	double r = Math.abs(radius);
    	//Calculate the fast and slow wheel speeds.
    	double slow = speed * (r - w) / (r + w);
    	//Calculate the expected rate of turn based on wheel speed ratio.
    	double omega = speed / slow * (radius/Math.abs(radius)) * 2.0 * Math.PI;
    	//Adjust the slow wheel to compensate.
    	double g = Robot.measurement.getGyroRate();
    	slow = slow * omega / g;
    	//Set motor speeds.
    	//Case for straight ahead.
    	if (radius > 500*width)  {
    		leftMotor.set(speed);
    		rightMotor.set(speed);
    	}
    	//Case for right turn.
    	else if (radius > 0.0)  {
    		leftMotor.set(speed);
    		rightMotor.set(slow);
    	}
    	//Case for left turn.
    	else if (radius < 0.0)  {
    		leftMotor.set(slow);
    		rightMotor.set(speed);
    	}
    	System.out.println("speed="+speed+" radius="+radius);
    	System.out.println(" slow="+slow+ " omega="+omega+" gyro="+g);
    }    
}

