// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.RecycleRush3.subsystems;

import org.usfirst.frc4579.RecycleRush3.Robot;
import org.usfirst.frc4579.RecycleRush3.RobotMap;
import org.usfirst.frc4579.RecycleRush3.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;


/**
 *
 */
public class Measurement extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Gyro gyro = RobotMap.measurementGyro;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private double	totalDistance = 0., // Total distance travelled
    				distanceX = 0., // Total sideways distance: X-axis on accel
    				distanceY = 0., // Total forwards distance: Z-axis on accel
    				driftRate = 0., // Gyro drift rate in degrees/second
    				lastTime = 0.,  // Calculates change in time
    				lastVelocity = 0., // Vi (Initial Velocity)
    				velocity = 0.,  // V (Velocity)
    				accelX = 0., //given from getX() due to the roborio orientation
    				accelY = 0., // given from getZ() due to the roborio orientation
    				gyroAngle = 0.;
	private double accelOffsetX = 0.;
	private double accelOffsetY = 0.;

    private boolean validity = false; // True after initialization.
    private Timer timer = new Timer();
    private Accelerometer robotAccelerometer = RobotMap.robotAccelerometer;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new Accumulate());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void calibrate() {
    	System.out.println("Initiating Calibration***");
    	double timein = Timer.getFPGATimestamp();
    	gyro.reset(); // Initializes gyro to zero
    	Timer.delay(1.); // Delay to get sample
    	driftRate = gyro.getAngle(); // sets the degrees per second of drift
    	for (int i=0; i<100; i++)  {
    		accelOffsetX += robotAccelerometer.getY();
    		accelOffsetY += robotAccelerometer.getZ();
    	}
    	accelOffsetX /= 100.;
    	accelOffsetY /= 100.;
    	accelX = 0.0;
    	accelY = 0.0;
    	System.out.println("Time for calibration: " + (Timer.getFPGATimestamp()-timein) + " seconds..."); 
    	
    	System.out.print("DRIFT RATE: " + driftRate + "\nAccelOffsetX: " + accelOffsetX + "\nAccelOffsetY: " + accelOffsetY);
    }
    
    
    public void initialize() {
    	gyro.reset();
    	lastTime = 0.;
    	setValid();
    }
    
    public double getTime() {
    	return timer.get();
    }
    
    public void readAccelerometer() { // sets local variables for x and y robot acceleration
    	accelX = robotAccelerometer.getY() - accelOffsetX;
    	accelY = robotAccelerometer.getZ() - accelOffsetY;
    }
    
    public double getAcceleration() {
    	return Math.sqrt(Math.pow(accelX, 2) + Math.pow(accelY, 2));
    }
    
    public void accumulate() {
    	readAccelerometer(); // Sets the acceleration of the indivudual rio axis
    	gyroAngle = gyro.getAngle() - (driftRate * timer.get());
    	double accel = getAcceleration(),
    			t = timer.get(),
    			deltaT = t - lastTime;
    	lastTime = t;
    	velocity = lastVelocity + (accel*deltaT); // Calculates velocity
    	double deltaD = velocity + (0.5 * accel * Math.pow(deltaT, 2)); // Calculates change in distance
    	totalDistance += deltaD;
    	distanceX += Math.cos(gyroAngle) * deltaD;
    	distanceY += Math.sin(gyroAngle) * deltaD;
    }
    
    public double getVelocity() {
    	return velocity;
    }
    
    public double getDistance() {
    	return totalDistance;
    }
    
    public double getDistanceFwd() {
    	return distanceX;
    }
    
    public double getDistanceSide() {
    	return distanceY;
    }
    
    public double getAngle() {
    	return gyroAngle;
    }
    
    public void setValid() {
    	validity = true;
    }
    
    public void setInvalid() {
    	validity = false;
    }
    
    public boolean isInvalid() {
    	return validity;
    }
    
    
}

